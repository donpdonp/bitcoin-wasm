<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<style>
.codestack { 
 display: grid;
 grid-template-columns: 1fr 1fr;
}
.lineno { font-size: 80% }
#scriptouts { font-family: courier; }
#codeinputs textarea { width: 35em; height: 10em; }
</style>
<script src="bridge.js"></script>
</head>
<body>
<div id="banner">
bitcoin script <span id="loading">(loading wasm...)</span>
</div>

<div class="codestack">

<div class="code">
<div>
Bitcoin Script
</div>
<form onSubmit="justgo(); return false">
<div id="codeinputs">
<textarea></textarea>
</div>
<input type=submit name="run" value="Run" />
<form>
</div>

<div class="stack">
<span class="stackhead">Stack [hex]</span>
<div id="scriptouts">
</div>
</div>

<div>
Compiled script bytes
<div id="codeout">
</div>
</div>

</div>

<script>
var inputsDiv = document.getElementById('codeinputs')
var scriptoutsDiv = document.getElementById('scriptouts')

Module['onRuntimeInitialized'] = onRuntimeInitialized;
function onRuntimeInitialized() {
  document.querySelector('#banner').style.backgroundColor="#0f0"
  var verz = Module.ccall('version', 'string', [], [])
  document.querySelector('#loading').innerHTML = "(dogecoin "+verz + " ready)"
}

function inputInputs() {
  var inputText = document.querySelector('#codeinputs textarea')
  var inputs = inputText.value.split('\n').map(function(line){
    line = line.toUpperCase()
    return line
  })
  return inputs.clean('')
}

function inputOutputs(ops) {
  var outElements = document.querySelector('#codeout')
  outElements.innerHTML = '' //clear
  ops.forEach((op, i) => {
    var msg =  Array.from(op).map(o => {
      var msg = o.toString(16)
      var pmsg = msg.length == 1 ? '0'+msg : msg
      return pmsg
    }).join('')
    var el = document.createElement('div')
    if (msg.length > 25) { msg = msg.substr(0,25)+"..."+msg.substr(msg.length-2, 2) }
    el.innerHTML = "<span class='lineno'>op "+(i+1)+":</span> 0x"+msg
    outElements.appendChild(el)
  })
}

function justgo() {
  console.log('--- js script run')
  var scriptIdx = compile(inputInputs())
  var ops = decompile(scriptIdx)
  inputOutputs(ops)
  var stack = scriptRun(scriptIdx)
  stackOutputs(stack)
}

function stackSuccess(success) {
  var stackHead = document.querySelector('.stackhead')
  var color = success ? "#0f0" : "#f00"
  stackHead.style.backgroundColor = color
}

function stackOutputs(stack) {
  scriptoutsDiv.innerHTML = '' // clean out
  stack.forEach(function(s,i){
    var el = document.createElement('div')
    el.innerHTML= stackBytestoString(s)
    scriptoutsDiv.appendChild(el)
  })
}

function stackBytestoString(s) {
    var msg = "(empty)"
    if(s.length > 4) {
      msg = toHex(s)+' ('+s.length+' bytes)'
    } else {
      s.reverse() // happens in-place
      var negative = 1
      if(s[0] & 0x80) {
        s[0] &= ~0x80
        negative = -1
      }
      var sint = s.reduce(function(m,e){ return (m<<8|e) }, 0)  * negative
      msg = sint
      msg += '(number) [0x'+Object.values(s).map(function(s){var hex=s.toString(16); return hex.length == 1 ? '0'+hex : hex}).join('')+']'
    }
    return msg
}

function compile(ops) {
  console.log('js compile opslen', ops.length, ops)
  var strBufArr = ops.map(function(s){ 
    var bbuf = Module._malloc(s.length+1); 
    Module.writeAsciiToMemory(s, bbuf);
    return bbuf } )
  var heapBytes = _arrayToHeap(new Uint32Array(strBufArr))
  var idx = Module.ccall('stringCompile', 'number', ['number', 'number'], 
                            [heapBytes.byteOffset, ops.length])
  console.log('compiled to script', '#'+idx)
  return idx
}

function decompile(idx) {
  var code = Module.ccall('decompile', 'number', ['number'], [idx])
  var linecount = Module.getValue(code, 'i32')
  var lines = []
  var linesheap = Module.getValue(code+4, '*')
  console.log('js decompiled to ', 'codeptr:'+code, 'lines:'+linecount, 'linesheap:'+linesheap)
  for(var i=0; i<linecount; i++){ 
    var lineheap = Module.getValue(linesheap+(4*i), '*')
    var linelen = Module.getValue(lineheap, 'i8')
    console.log('js decompile line', '#'+i, 'ptr:'+lineheap, 'len:'+linelen)
    var stkrow = new Uint8Array(Module.HEAPU8.buffer, lineheap+1, linelen);
    lines.push(stkrow)
  }
  return lines
}

function scriptRun(idx) {
  var struct = Module.ccall('scriptRun', 'number', ['number'], [idx])
  var success = Module.getValue(struct, 'i8')
  stackSuccess(success)
  var len = Module.getValue(struct+4, 'i32')
  console.log('scriptRun post success', success, 'stklen', len)
  var stk = []
  var charheap = Module.getValue(struct+8, '*')
  for(var i=0; i<len; i++){ 
    var rowheap = Module.getValue(charheap+(4*i), '*')
    var stkrowlen = Module.getValue(rowheap, 'i8')
    var stkrow = new Uint8Array(Module.HEAPU8.buffer, rowheap+1, stkrowlen);
    stk.push(stkrow)
  }
  return stk
}

function _arrayToHeap(typedArray){
  var numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
  var ptr = Module._malloc(numBytes);
  var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
  heapBytes.set(new Uint8Array(typedArray.buffer));
  return heapBytes;
}

function toHex(s) {
    var h = ''
    for (var i = 0; i < s.length; i++) {
        var hexDigits = s[i].toString(16)
        if(hexDigits.length <2) { hexDigits = '0'+hexDigits }
        h += hexDigits
    }
    return h
}

function fromHex(h) {
    var s = ''
    for (var i = 0; i < h.length; i+=2) {
        s += String.fromCharCode(parseInt(h.substr(i, 2), 16))
    }
    return s
}

Array.prototype.clean = function(deleteValue) {
  for (var i = 0; i < this.length; i++) {
    if (this[i] == deleteValue) {         
      this.splice(i, 1);
      i--;
    }
  }
  return this;
};
</script>

</body>
</html>
